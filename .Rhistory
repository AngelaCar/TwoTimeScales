# if u is already = to one of the interval points, do nothing, otherwise
if(!(u %in% new_grid$intu)){
if(u < new_grid$umin | u > new_grid$umax){
stop ("New `u` outside of range of `B_u`.")
} else {
newu <- unique(sort(c(new_grid$intu, u)))
new_grid$intu <- newu
}
}
Bu <- JOPS::bbase(new_grid$intu, nseg = attributes(Bbases$Bu)$nseg,
bdeg = attributes(Bbases$Bu)$bdeg)
# do the same for s
if(!(s %in% new_grid$ints)){
if(s < new_grid$smin | s > new_grid$smax){
stop ("New `s` outside of range of `B_s`.")
} else {
news <- unique(sort(c(new_grid$ints, s)))
new_grid$ints <- news
}
}
Bs <- JOPS::bbase(new_grid$ints, nseg = attributes(Bbases$Bs)$nseg,
bdeg = attributes(Bbases$Bs)$bdeg)
# Now calculate hazard and only select the value corresponding to the new u,s pair
# ---- Calculate (baseline) hazard ----
Eta <- Bu %*% fitted_model$optimal_model$Alpha %*% t(Bs)
Haz <- exp(Eta)
Haz == old_haz
Bbases <- fitted_model$optimal_model$Bbases
midu <- attributes(Bbases$Bu)$x
mids <- attributes(Bbases$Bs)$x
# du <- midu[2] - midu[1]
# ds <- mids[2] - mids[1]
# intu <- midu + du / 2
# intu <- c(intu[1] - du, intu)
umin <- attributes(Bbases$Bu)$xl
umax <- attributes(Bbases$Bu)$xr
# ints <- mids + ds / 2
# ints <- c(ints[1] - ds, ints)
smin <- attributes(Bbases$Bs)$xl
smax <- attributes(Bbases$Bs)$xr
new_grid <- list(
"intu" = midu,
"umin" = umin,
"umax" = umax,
"ints" = mids,
"smin" = smin,
"smax" = smax
)
# if u is already = to one of the interval points, do nothing, otherwise
if(!(u %in% new_grid$intu)){
if(u < new_grid$umin | u > new_grid$umax){
stop ("New `u` outside of range of `B_u`.")
} else {
newu <- unique(sort(c(new_grid$intu, u)))
new_grid$intu <- newu
}
}
Bu <- JOPS::bbase(new_grid$intu, nseg = attributes(Bbases$Bu)$nseg,
bdeg = attributes(Bbases$Bu)$bdeg)
# do the same for s
if(!(s %in% new_grid$ints)){
if(s < new_grid$smin | s > new_grid$smax){
stop ("New `s` outside of range of `B_s`.")
} else {
news <- unique(sort(c(new_grid$ints, s)))
new_grid$ints <- news
}
}
Bs <- JOPS::bbase(new_grid$ints, nseg = attributes(Bbases$Bs)$nseg,
bdeg = attributes(Bbases$Bs)$bdeg)
# Now calculate hazard and only select the value corresponding to the new u,s pair
# ---- Calculate (baseline) hazard ----
Eta <- Bu %*% fitted_model$optimal_model$Alpha %*% t(Bs)
Haz <- exp(Eta)
new_grid$intu
new_u
Bbases <- fitted_model$optimal_model$Bbases
midu <- attributes(Bbases$Bu)$x
mids <- attributes(Bbases$Bs)$x
# du <- midu[2] - midu[1]
# ds <- mids[2] - mids[1]
# intu <- midu + du / 2
# intu <- c(intu[1] - du, intu)
umin <- attributes(Bbases$Bu)$xl
umax <- attributes(Bbases$Bu)$xr
# ints <- mids + ds / 2
# ints <- c(ints[1] - ds, ints)
smin <- attributes(Bbases$Bs)$xl
smax <- attributes(Bbases$Bs)$xr
new_grid <- list(
"intu" = midu,
"umin" = umin,
"umax" = umax,
"ints" = mids,
"smin" = smin,
"smax" = smax
)
Bu <- JOPS::bbase(new_grid$intu, nseg = attributes(Bbases$Bu)$nseg,
bdeg = attributes(Bbases$Bu)$bdeg)
Bs <- JOPS::bbase(new_grid$ints, nseg = attributes(Bbases$Bs)$nseg,
bdeg = attributes(Bbases$Bs)$bdeg)
Eta <- Bu %*% fitted_model$optimal_model$Alpha %*% t(Bs)
Haz <- exp(Eta)
Haz == old_haz
View(Haz)
View(old_haz)
Bu == Bbases$Bu
View(Bbases)
Bbases[["Bu"]]
View(Bu)
new_grid$intu
attributes(Bbases$Bu)$x
Bu
attributes(Bbases$Bu)$xl
Bu <- JOPS::bbase(new_grid$intu,
xl = umin, xr = umax,
nseg = attributes(Bbases$Bu)$nseg,
bdeg = attributes(Bbases$Bu)$bdeg)
Bu
Bs <- JOPS::bbase(new_grid$ints, nseg = attributes(Bbases$Bs)$nseg,
xl = smin, xr = smax,
bdeg = attributes(Bbases$Bs)$bdeg)
Eta <- Bu %*% fitted_model$optimal_model$Alpha %*% t(Bs)
Haz <- exp(Eta)
Haz == old_haz
devtools::load_all(".")
id <- 1:20
u <- c(
5.43, 3.25, 8.15, 5.53, 7.28, 6.61, 5.91, 4.94, 4.25, 3.86, 4.05, 6.86,
4.94, 4.46, 2.14, 7.56, 5.55, 7.60, 6.46, 4.96
)
s <- c(
0.44, 4.89, 0.92, 1.81, 2.02, 1.55, 3.16, 6.36, 0.66, 2.02, 1.22, 3.96,
7.07, 2.91, 3.38, 2.36, 1.74, 0.06, 5.76, 3.00
)
ev <- c(1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1)
fakedata <- as.data.frame(cbind(id, u, s, ev))
fakedata2ts <- prepare_data(
u = fakedata$u,
s_out = fakedata$s,
ev = fakedata$ev,
ds = .5,
min_u = 2, min_s = 0
)
# Fit a fake model - not optimal smoothing
fakemod <- fit2ts(fakedata2ts,
optim_method = "grid_search",
lrho = list(
seq(1, 1.5, .5),
seq(1, 1.5, .5)
)
)
# Create a new dataset for prediction
newdata <- as.data.frame(cbind("u" = c(2.5, 3.4, 6), "s" = c(.2, .5, 1.3)))
haz <- get_hazard_2d(fakemod,
plot_grid = list(c(2, 8, .1),
c(0, 7.1, .1)))
nu <- haz$new_plot_grid$intu
ns <- haz$new_plot_grid$ints
which(nu == u) #6, 15, 41
"u" = c(2.5, 3.4, 6)
"s" = c(.2, .5, 1.3)
which(nu == u) #6, 15, 41
which(ns == s) #3,
which(nu %in% u) #6, 15, 41
which(ns %in% s) #3, 6, 14
haz$hazard[6, 3]
# Now - predict on new dataset
predict(object = fakemod,
newdata = newdata, u = "u", s = "s"
)
devtools::load_all(".")
haz <- get_hazard_2d(fakemod,
plot_grid = list(c(2, 8, .1),
c(0, 7.1, .1)))
nu <- haz$new_plot_grid$intu
ns <- haz$new_plot_grid$ints
which(nu %in% u) #6, 15, 41
which(ns %in% s) #3, 6, 14
haz$hazard[6, 3]
id <- 1:20
u <- c(5.43, 3.25, 8.15, 5.53, 7.28, 6.61, 5.91, 4.94, 4.25, 3.86, 4.05, 6.86,
4.94, 4.46, 2.14, 7.56, 5.55, 7.60, 6.46, 4.96)
s <- c(0.44, 4.89, 0.92, 1.81, 2.02, 1.55, 3.16, 6.36, 0.66, 2.02, 1.22, 3.96,
7.07, 2.91, 3.38, 2.36, 1.74, 0.06, 5.76, 3.00)
ev <- c(1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1)
fakedata <- as.data.frame(cbind(id, u, s, ev))
# cause 1
fakedata2ts1 <- prepare_data(u = fakedata$u,
s_out = fakedata$s,
ev = fakedata$ev,
ds = .5)
# Fit a fake model - not optimal smoothing for cause type 1
fakemod1 <- fit2ts(fakedata2ts1,
optim_method = "grid_search",
lrho = list(seq(1 ,1.5 ,.5),
seq(1 ,1.5 ,.5)))
# cause 2
fakedata2ts2 <- prepare_data(u = fakedata$u,
s_out = fakedata$s,
ev = 1-(fakedata$ev),
ds = .5)
# Fit a fake model - not optimal smoothing for cause 2
fakemod2 <- fit2ts(fakedata2ts2,
optim_method = "grid_search",
lrho = list(seq(1 ,1.5 ,.5),
seq(1 ,1.5 ,.5)))
# cause 1
fakedata2ts1 <- prepare_data(u = fakedata$u,
s_out = fakedata$s,
ev = fakedata$ev,
min_u = 2, min_s = 0,
ds = .5)
# cause 2
fakedata2ts2 <- prepare_data(u = fakedata$u,
s_out = fakedata$s,
ev = 1-(fakedata$ev),
min_u = 2, min_s = 0,
ds = .5)
# Fit a fake model - not optimal smoothing for cause type 1
fakemod1 <- fit2ts(fakedata2ts1,
optim_method = "grid_search",
lrho = list(seq(1 ,1.5 ,.5),
seq(1 ,1.5 ,.5)))
# Fit a fake model - not optimal smoothing for cause 2
fakemod2 <- fit2ts(fakedata2ts2,
optim_method = "grid_search",
lrho = list(seq(1 ,1.5 ,.5),
seq(1 ,1.5 ,.5)))
fitted_models = list(fakemod1, fakemod2)
s = 4.4
u = 5.3
Bbases <- fitted_models[[1]]$optimal_model$Bbases
midu <- attributes(Bbases$Bu)$x
mids <- attributes(Bbases$Bs)$x
umin <- attributes(Bbases$Bu)$xl
umax <- attributes(Bbases$Bu)$xr
smin <- attributes(Bbases$Bs)$xl
smax <- attributes(Bbases$Bs)$xr
new_grid <- list(
"intu" = midu,
"umin" = umin,
"umax" = umax,
"ints" = mids,
"smin" = smin,
"smax" = smax
)
# if u is already = to one of the interval points, do nothing, otherwise
if(!(u %in% new_grid$intu)){
if(u < new_grid$umin | u > new_grid$umax){
stop ("New `u` outside of range of `B_u`.")
} else {
newu <- unique(sort(c(new_grid$intu, u)))
new_grid$intu <- newu
}
}
Bu <- JOPS::bbase(new_grid$intu,
xl = umin, xr = umax,
nseg = attributes(Bbases$Bu)$nseg,
bdeg = attributes(Bbases$Bu)$bdeg)
# do the same for s
if(!(s %in% new_grid$ints)){
if(s < new_grid$smin | s > new_grid$smax){
stop ("New `s` outside of range of `B_s`.")
} else {
news <- unique(sort(c(new_grid$ints, s)))
new_grid$ints <- news
}
}
Bs <- JOPS::bbase(new_grid$ints,
nseg = attributes(Bbases$Bs)$nseg,
xl = smin, xr = smax,
bdeg = attributes(Bbases$Bs)$bdeg)
grid_us <- expand.grid(u = new_grid$intu, s = new_grid$ints)
n <- nrow(grid_us)
L <- length(fitted_models) # n. of competing causes
J <- dim(Bu)[1]
K <- dim(Bs)[1]
csh_a <- array(NA, dim = c(J, K+1, L))
csh <- matrix(0, n, L)
colnames(csh) <- paste0("csh_", 1:L)
cscumh_a <- array(NA, dim = c(J, K+1, L))
cif_a <- array(NA, dim = c(J, K+1, L))
cif <- matrix(0, n, L)
colnames(cif) <- paste0("cif_", 1:L)
Eta <- Bu %*% fitted_models[[l]]$optimal_model$Alpha %*% t(Bs)
# ---- Cumulative hazard ----
ds <- diff(c(0,new_grid$ints))
c(0,new_grid$ints)
ds
#ds <- ds, max(ds))
csh_a[, , l] <- cbind(rep(0, J), csh_a[, 2:(K+1), l])
l = 1
Eta <- Bu %*% fitted_models[[l]]$optimal_model$Alpha %*% t(Bs)
csh_a[, 2:(K+1), l] <- exp(Eta)
csh[, l] <- c(csh_a[, 2:(K+1), l])
# ---- Cumulative hazard ----
ds <- diff(c(0,new_grid$ints))
#ds <- ds, max(ds))
csh_a[, , l] <- cbind(rep(0, J), csh_a[, 2:(K+1), l])
cscumh_a[, , l] <- t(apply(csh_a[, , l] * ds, 1, cumsum) )
csh_a <- array(NA, dim = c(J, K, L))
csh <- matrix(0, n, L)
colnames(csh) <- paste0("csh_", 1:L)
cscumh_a <- array(NA, dim = c(J, K, L))
#cscumh <- matrix(0, n, L)
#colnames(cscumh) <- paste0("cscumh_", 1:L)
cif_a <- array(NA, dim = c(J, K, L))
cif <- matrix(0, n, L)
colnames(cif) <- paste0("cif_", 1:L)
# ---- Calculate (baseline) hazard ----
Eta <- Bu %*% fitted_models[[l]]$optimal_model$Alpha %*% t(Bs)
csh_a[, , l] <- exp(Eta)
csh[, l] <- c(csh_a[, , l])
# ---- Cumulative hazard ----
ds <- diff(c(0,new_grid$ints))
#ds <- ds, max(ds))
#csh_a[, , l] <- cbind(csh_a[, 2:(K+1), l])
cscumh_a[, , l] <- t(apply(csh_a[, , l] * ds, 1, cumsum) )
surv <- exp(-(apply(cscumh_a, 1:2, sum)))
surv
for(l in 1:L){
# ---- Calculate (baseline) hazard ----
Eta <- Bu %*% fitted_models[[l]]$optimal_model$Alpha %*% t(Bs)
csh_a[, , l] <- exp(Eta)
csh[, l] <- c(csh_a[, , l])
# ---- Cumulative hazard ----
ds <- diff(c(0,new_grid$ints))
#ds <- ds, max(ds))
#csh_a[, , l] <- cbind(csh_a[, 2:(K+1), l])
cscumh_a[, , l] <- t(apply(csh_a[, , l] * ds, 1, cumsum) )
#cscumh[, l] <- c(cscumh_a[, , l] )
}
surv <- exp(-(apply(cscumh_a, 1:2, sum)))
surv
grid_us$surv <- c(surv)
for (l in 1:L) {
cif_a[, , l] <- t(apply((csh_a[, , l] * surv) * ds, 1, cumsum) )
cif[, l] <- c(cif_a[, , l])
}
grid_us <- cbind(grid_us, cif)
selection <- grid_us[grid_us$u == u & grid_us$s == s,]
devtools::load_all(".")
predict_cif2ts_pointwise(fitted_models = list(fakemod1, fakemod2),
u = 5.3, s = 4.4)
fakecumhaz2ts <- cumhaz2ts(list(fakemod1, fakemod2))
fakecumhaz2ts1 <- cumhaz2ts(fakemod1)
fakecumhaz2ts2 <- cumhaz2ts(fakemod2)
# Fake cumulative incidence function 2ts
fakecif2ts <- cuminc2ts(haz = list(fakecumhaz2ts1$Haz$hazard, fakecumhaz2ts2$Haz$hazard),
ds = .5)
cif1 <- fakecif2ts[[1]]
new_u <- fakecumhaz2ts1$Haz$new_plot_grid$intu
new_u <- fakecumhaz2ts1$Haz$new_plot_grid$intu
new_s <- fakecumhaz2ts1$Haz$new_plot_grid$ints
new_u
new_s
predict_cif2ts_pointwise(fitted_models = list(fakemod1, fakemod2),
u = 5.25, s = 4.25)
which(new_u == 5.25)
which(new_s == 4.25)
cif1[7,9]
devtools::load_all(".")
fakecumhaz2ts1 <- cumhaz2ts(fakemod1)
fakecumhaz2ts2 <- cumhaz2ts(fakemod2)
# Fake cumulative incidence function 2ts
fakecif2ts <- cuminc2ts(haz = list(fakecumhaz2ts1$Haz$hazard, fakecumhaz2ts2$Haz$hazard),
ds = .5)
new_u <- fakecumhaz2ts1$Haz$new_plot_grid$intu
new_s <- fakecumhaz2ts1$Haz$new_plot_grid$ints
cif1 <- fakecif2ts[[1]]
cif1[7,9]
l = 1
csh_a[1, 1, l]
csh_a[1, 1, l] * ds[1]
csh_a[1, 1, l] * ds[1]  + csh_a[1, 2, l] * ds[2]
csh_a[1, 1, l] * ds[1]  + csh_a[1, 2, l] * ds[2] + csh_a[1, 3, l] * ds[3]
for(k in 1:K){ csh_a[1, k, l] * ds[k]}
for(k in 1:K){ print(csh_a[1, k, l] * ds[k])}
apply((csh_a[1, , l] * surv) * ds, 1, cumsum)
for(k in 1:K){ cumsum(csh_a[1, k, l] * ds[k])}
for(k in 1:K){ print(cumsum(csh_a[1, k, l] * ds[k]))}
for(k in 1:K){ aa[k] <- csh_a[1, k, l] * ds[k]}
aa <- ()
aa <- c()
for(k in 1:K){ aa[k] <- csh_a[1, k, l] * ds[k]}
aa
cumsum(aa)
apply(csh_a[1, , l] * ds, 1, cumsum)
cumsum(csh_a[1,,l] * ds)
apply(csh_a[, , l] * ds, 1, cumsum)
predict_cif2ts_pointwise(fitted_models = list(fakemod1, fakemod2),
u = 5.25, s = 4.25)
cscumh_a
#surv <- exp(-(apply(cscumh_a, 1:2, sum)))
surv <- exp(-(Reduce("+", cscumh_a)))
surv2 <- exp(-(apply(cscumh_a, 1:2, sum)))
surv == surv2
View(surv2)
surv <- exp(-(Reduce("+", cscumh_a[,,])))
surv <- exp(-(Reduce("+", cscumh_a[,])))
surv <- exp(-(Reduce("+", cscumh_a[,,1:L])))
surv <- exp(-(Reduce("+", cscumh_a[1:J,1:K,1:L])))
for(l in 1:L) {cscumh_l[[l]] <- cscumh_a[,,l]}
cscumh_l <- vector("list", length = L)
for(l in 1:L) {cscumh_l[[l]] <- cscumh_a[,,l]}
surv <- exp(-(Reduce("+", cscumh_l)))
surv == surv2
fakecumhaz2ts1$Haz$hazard
fakecumhaz2ts1$Haz$hazard[7,9]
csh_a[7,9 , 1]
fakecumhaz2ts1$CumHaz[7,9]
cscumh_a[7,9 , 1]
devtools::load_all(".")
id <- 1:20
u <- c(5.43, 3.25, 8.15, 5.53, 7.28, 6.61, 5.91, 4.94, 4.25, 3.86, 4.05, 6.86,
4.94, 4.46, 2.14, 7.56, 5.55, 7.60, 6.46, 4.96)
s <- c(0.44, 4.89, 0.92, 1.81, 2.02, 1.55, 3.16, 6.36, 0.66, 2.02, 1.22, 3.96,
7.07, 2.91, 3.38, 2.36, 1.74, 0.06, 5.76, 3.00)
ev <- c(1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1)
fakedata <- as.data.frame(cbind(id, u, s, ev))
# cause 1
fakedata2ts1 <- prepare_data(u = fakedata$u,
s_out = fakedata$s,
ev = fakedata$ev,
min_u = 2, min_s = 0,
ds = .5)
# Fit a fake model - not optimal smoothing for cause type 1
fakemod1 <- fit2ts(fakedata2ts1,
optim_method = "grid_search",
lrho = list(seq(1 ,1.5 ,.5),
seq(1 ,1.5 ,.5)))
# cause 2
fakedata2ts2 <- prepare_data(u = fakedata$u,
s_out = fakedata$s,
ev = 1-(fakedata$ev),
min_u = 2, min_s = 0,
ds = .5)
# Fit a fake model - not optimal smoothing for cause 2
fakemod2 <- fit2ts(fakedata2ts2,
optim_method = "grid_search",
lrho = list(seq(1 ,1.5 ,.5),
seq(1 ,1.5 ,.5)))
fitted_models = list(fakemod1, fakemod2)
u = 5.25
s = 4.25
Bbases <- fitted_models[[1]]$optimal_model$Bbases
midu <- attributes(Bbases$Bu)$x
mids <- attributes(Bbases$Bs)$x
umin <- attributes(Bbases$Bu)$xl
umax <- attributes(Bbases$Bu)$xr
smin <- attributes(Bbases$Bs)$xl
smax <- attributes(Bbases$Bs)$xr
new_grid <- list(
"intu" = midu,
"umin" = umin,
"umax" = umax,
"ints" = mids,
"smin" = smin,
"smax" = smax
)
u %in% new_grid$intu
if(!(u %in% new_grid$intu)){
if(u < new_grid$umin | u > new_grid$umax){
stop ("New `u` outside of range of `B_u`.")
} else {
newu <- unique(sort(c(new_grid$intu, u)))
new_grid$intu <- newu
}
}
Bu <- JOPS::bbase(new_grid$intu,
xl = umin, xr = umax,
nseg = attributes(Bbases$Bu)$nseg,
bdeg = attributes(Bbases$Bu)$bdeg)
# do the same for s
if(!(s %in% new_grid$ints)){
if(s < new_grid$smin | s > new_grid$smax){
stop ("New `s` outside of range of `B_s`.")
} else {
news <- unique(sort(c(new_grid$ints, s)))
new_grid$ints <- news
}
}
Bs <- JOPS::bbase(new_grid$ints,
nseg = attributes(Bbases$Bs)$nseg,
xl = smin, xr = smax,
bdeg = attributes(Bbases$Bs)$bdeg)
grid_us <- expand.grid(u = new_grid$intu, s = new_grid$ints)
n <- nrow(grid_us)
L <- length(fitted_models) # n. of competing causes
J <- dim(Bu)[1]
K <- dim(Bs)[1]
csh_a <- array(NA, dim = c(J, K, L))
csh <- matrix(0, n, L)
colnames(csh) <- paste0("csh_", 1:L)
cscumh_a <- array(NA, dim = c(J, K, L))
#cscumh <- matrix(0, n, L)
#colnames(cscumh) <- paste0("cscumh_", 1:L)
cif_a <- array(NA, dim = c(J, K, L))
cif <- matrix(0, n, L)
colnames(cif) <- paste0("cif_", 1:L)
l = 1
Eta <- Bu %*% fitted_models[[l]]$optimal_model$Alpha %*% t(Bs)
csh_a[, , l] <- exp(Eta)
csh[, l] <- c(csh_a[, , l])
# ---- Cumulative hazard ----
ds <- diff(c(0,new_grid$ints))
ds
new_grid$ints
# ---- Cumulative hazard ----
ds <- diff(new_grid$ints)
ds
